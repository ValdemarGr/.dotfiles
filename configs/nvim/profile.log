SCRIPT  /home/valde/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim
Sourced 1 time
Total time:   0.006107
 Self time:   0.002443

count  total (s)   self (s)
    1              0.000010 scriptencoding utf-8
                            " EasyMotion - Vim motions on speed!
                            "
                            " Author: Kim Silkeb√¶kken <kim.silkebaekken+vim@gmail.com>
                            "         haya14busa <hayabusa1419@gmail.com>
                            " Source: https://github.com/easymotion/vim-easymotion
                            "=============================================================================
                            " Saving 'cpoptions' {{{
    1              0.000028 let s:save_cpo = &cpo
    1   0.000057   0.000043 set cpo&vim
                            " }}}
                            
    1              0.000006 let s:TRUE = !0
    1              0.000004 let s:FALSE = 0
    1              0.000012 let s:DIRECTION = { 'forward': 0, 'backward': 1, 'bidirection': 2}
                            
                            
                            " Init: {{{
    1              0.000005 let s:loaded = s:FALSE
    1              0.000007 function! EasyMotion#init()
                                if s:loaded
                                    return
                                endif
                                let s:loaded = s:TRUE
                                call EasyMotion#highlight#load()
                                " Store previous motion info
                                let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
                                let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
                                let s:migemo_dicts = {}
                                let s:EasyMotion_is_active = 0
                                call EasyMotion#reset()
                                " Anywhere regular expression: {{{
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
                                let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
                                let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
                                let g:EasyMotion_ignore_exception = 0
                                return ""
                            endfunction
                            "}}}
                            " Reset: {{{
    1              0.000004 function! EasyMotion#reset()
                                let s:flag = {
                                    \ 'within_line' : 0,
                                    \ 'dot_repeat' : 0,
                                    \ 'regexp' : 0,
                                    \ 'bd_t' : 0,
                                    \ 'find_bd' : 0,
                                    \ 'linewise' : 0,
                                    \ 'count_dot_repeat' : 0,
                                    \ }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
                                let s:current = {
                                    \ 'is_operator' : 0,
                                    \ 'is_search' : 0,
                                    \ 'dot_repeat_target_cnt' : 0,
                                    \ 'dot_prompt_user_cnt' : 0,
                                    \ 'changedtick' : 0,
                                    \ }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
                                return ""
                            endfunction "}}}
                            
                            " Motion Functions: {{{
                            " -- Find Motion -------------------------
                            " Note: {{{
                            " num_strokes:
                            "   The number of input characters. Currently provide 1, 2, or -1.
                            "   '-1' means no limit.
                            " visualmode:
                            "   Vim script couldn't detect the function is called in visual mode by
                            "   mode(1), so tell whether it is in visual mode by argument explicitly
                            " direction:
                            "   0 -> forward
                            "   1 -> backward
                            "   2 -> bi-direction (handle forward & backward at the same time) }}}
    1              0.000006 function! EasyMotion#S(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 'f' motion is inclusive but
                                    " 'F' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000005 function! EasyMotion#OverwinF(num_strokes) " {{{
                                let re = s:findMotion(a:num_strokes, s:DIRECTION.bidirection)
                                call EasyMotion#reset()
                                if re isnot# ''
                                    return EasyMotion#overwin#move(re)
                                endif
                            endfunction "}}}
    1              0.000004 function! EasyMotion#T(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 't' motion is inclusive but
                                    " 'T' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                if a:direction == 2
                                    let s:flag.bd_t = 1
                                elseif a:direction == 1
                                    let re = s:convert_t_regexp(re, 1) " backward
                                else
                                    let re = s:convert_t_regexp(re, 0) " forward
                                endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Word Motion -------------------------
    1              0.000004 function! EasyMotion#WB(visualmode, direction) " {{{
                                "FIXME: inconsistent with default vim motion
                                "FIXED: -> EasyMotion#WBK()
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\<.\|^$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v(^|\s)\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#WBK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v<|^\S|\s\zs\S|>\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#E(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                call s:EasyMotion('\(.\>\|^$\)', a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'E' and 'gE' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v\S(\s|$)'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#EK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'e' and 'ge' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v.\ze>|\S\ze\s*$|\S\ze\s|\k\zs>\S\ze|\S<'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                            
                            
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JK Motion ---------------------------
    1              0.000003 function! EasyMotion#JK(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                            
                                if g:EasyMotion_startofline
                                    call s:EasyMotion('^\(\w\|\s*\zs\|$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                else
                                    let vcol  = EasyMotion#helper#vcol('.')
                                    let pattern = printf('^.\{-}\zs\(\%%<%dv.\%%>%dv\|$\)', vcol + 1, vcol)
                                    call s:EasyMotion(pattern, a:direction, a:visualmode ? visualmode() : '', 0)
                                endif
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#Sol(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                                call s:EasyMotion('^\(.\|$\)', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#Eol(visualmode, direction) " {{{
                                let s:flag.linewise = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\w\|\s*\zs\|.\|^\)$', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Search Motion -----------------------
    1              0.000005 function! EasyMotion#Search(visualmode, direction, respect_direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let search_direction = a:respect_direction ?
                                \   (a:direction == 1 ? v:searchforward : 1-v:searchforward) :
                                \   (a:direction)
                                call s:EasyMotion(@/, search_direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JumpToAnywhere Motion ---------------
    1              0.000004 function! EasyMotion#JumpToAnywhere(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion( g:EasyMotion_re_anywhere, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Line Motion -------------------------
    1              0.000004 function! EasyMotion#SL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#S(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#TL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#T(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#WBK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#EK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#LineAnywhere(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let re = g:EasyMotion_re_line_anywhere
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- User Motion -------------------------
    1              0.000032 let s:config = {
                            \   'pattern': '',
                            \   'visualmode': s:FALSE,
                            \   'direction': s:DIRECTION.forward,
                            \   'inclusive': s:FALSE,
                            \   'accept_cursor_pos': s:FALSE,
                            \   'overwin': s:FALSE
                            \ }
                            
    1              0.000008 function! s:default_config() abort
                                let c = copy(s:config)
                                let m = mode(1)
                                let c.inclusive = m ==# 'no' ? s:TRUE : s:FALSE
                                return c
                            endfunction
                            
    1              0.000003 function! EasyMotion#go(...) abort
                                let c = extend(s:default_config(), get(a:, 1, {}))
                                if c.overwin
                                    return EasyMotion#overwin#move(c.pattern)
                                else
                                    let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                    call s:EasyMotion(c.pattern, c.direction, c.visualmode ? visualmode() : '', c.inclusive, c)
                                    return s:EasyMotion_is_cancelled
                                endif
                            endfunction
    1              0.000005 function! EasyMotion#User(pattern, visualmode, direction, inclusive, ...) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? a:inclusive : 0
                                let re = a:pattern
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive, get(a:, 1, {}))
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Repeat Motion -----------------------
    1              0.000003 function! EasyMotion#Repeat(visualmode) " {{{
                                " Repeat previous motion with previous targets
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let direction = s:previous.direction
                                let s:flag.within_line = s:previous.line_flag
                                let s:flag.bd_t = s:previous.bd_t_flag
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " FIXME: is_inclusive value is inappropriate but handling this value is
                                " difficult and priorities is low because this motion maybe used usually
                                " as a 'normal' motion.
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                            
                                call s:EasyMotion(re, direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#DotRepeat() " {{{
                                let cnt = v:count1 " avoid overwriting
                            
                                " Repeat previous '.' motion with previous targets and operator
                                if !has_key(s:dot_repeat, 'regexp')
                                    call s:Message("Previous motion doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                            
                                let re = s:dot_repeat.regexp
                                let direction = s:dot_repeat.direction
                                let is_inclusive = s:dot_repeat.is_inclusive
                            
                                for i in range(cnt)
                                    " s:EasyMotion() always call reset s:flag & s:current
                                    let s:flag.dot_repeat = 1
                                    let s:flag.within_line = s:dot_repeat.line_flag
                                    let s:flag.bd_t = s:dot_repeat.bd_t_flag
                                    let s:current.is_operator = 1
                            
                                    let s:flag.count_dot_repeat = (i > 0 ? 1 : 0)
                                    silent call s:EasyMotion(re, direction, 0, is_inclusive)
                                endfor
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#NextPrevious(visualmode, direction) " {{{
                                " Move next/previous destination using previous motion regexp
                                let cnt = v:count1 " avoid overwriting
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let search_direction = (a:direction == 1 ? 'b' : '')
                            
                                if g:EasyMotion_move_highlight
                                    call EasyMotion#highlight#attach_autocmd()
                                    call EasyMotion#highlight#add_highlight(re, g:EasyMotion_hl_move)
                                endif
                            
                                if ! empty(a:visualmode)
                                    " FIXME: blink highlight
                                    silent exec 'normal! gv'
                                endif
                            
                                " Mark jump-list
                                if cnt > 1
                                    " Consider Next/Previous motions as jump motion :h jump-motion
                                    " Note: It should add jumplist even if the count isn't given
                                    "       considering vim's default behavior of `n` & `N`, but just
                                    "       I don't want to do it without the count. Should I add a
                                    "       option?
                                    normal! m`
                                endif
                            
                                " Jump
                                " @vimlint(EVL102, 1, l:_)
                                for _ in range(cnt)
                                    keepjumps call searchpos(re, search_direction)
                                endfor
                            
                                normal! zv
                            
                                call EasyMotion#reset()
                                " -- Activate EasyMotion ----------------- {{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd() "}}}
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " }}}
                            " Helper Functions: {{{
                            " -- Message -----------------------------
    1              0.000005 function! s:Message(message) " {{{
                                if g:EasyMotion_verbose
                                    echo 'EasyMotion: ' . a:message
                                else
                                    " Make the current message disappear
                                    echo ''
                                    " redraw
                                endif
                            endfunction " }}}
    1              0.000004 function! s:Prompt(message) " {{{
                                echohl Question
                                echo a:message . ': '
                                echohl None
                            endfunction " }}}
    1              0.000003 function! s:Throw(message) "{{{
                                throw 'EasyMotion: ' . a:message
                            endfunction "}}}
                            
                            " -- Save & Restore values ---------------
    1              0.000003 function! s:SaveValue() "{{{
                                if ! s:current.is_search
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
                                endif
                                call EasyMotion#helper#VarReset('&modified', 0)
                                call EasyMotion#helper#VarReset('&modifiable', 1)
                                call EasyMotion#helper#VarReset('&readonly', 0)
                                call EasyMotion#helper#VarReset('&spell', 0)
                                call EasyMotion#helper#VarReset('&virtualedit', '')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod', 'manual')
                                " endif
                            endfunction "}}}
    1              0.000003 function! s:RestoreValue() "{{{
                                call EasyMotion#helper#VarReset('&scrolloff')
                                call EasyMotion#helper#VarReset('&modified')
                                call EasyMotion#helper#VarReset('&modifiable')
                                call EasyMotion#helper#VarReset('&readonly')
                                call EasyMotion#helper#VarReset('&spell')
                                call EasyMotion#helper#VarReset('&virtualedit')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod')
                                " endif
                            endfunction "}}}
    1              0.000004 function! s:turn_off_hl_error() "{{{
                                let s:error_hl = EasyMotion#highlight#capture('Error')
                                call EasyMotion#highlight#turn_off(s:error_hl)
                                let s:matchparen_hl = EasyMotion#highlight#capture('MatchParen')
                                call EasyMotion#highlight#turn_off(s:matchparen_hl)
                            endfunction "}}}
    1              0.000004 function! s:turn_on_hl_error() "{{{
                                if exists('s:error_hl')
                                    call EasyMotion#highlight#turn_on(s:error_hl)
                                    unlet s:error_hl
                                endif
                            
                                if exists('s:matchparen_hl')
                                    call EasyMotion#highlight#turn_on(s:matchparen_hl)
                                    unlet s:matchparen_hl
                                endif
                            endfunction "}}}
                            
                            " -- Draw --------------------------------
    1              0.000004 function! s:SetLines(lines, key) " {{{
                                for [line_num, line] in a:lines
                                    keepjumps call setline(line_num, line[a:key])
                                endfor
                            endfunction " }}}
                            
                            " -- Get characters from user input ------
    1              0.000003 function! s:GetChar(...) abort "{{{
                                let mode = get(a:, 1, 0)
                                while 1
                                    " Workaround for https://github.com/osyo-manga/vital-over/issues/53
                                    try
                                        let char = call('getchar', a:000)
                                    catch /^Vim:Interrupt$/
                                        let char = 3 " <C-c>
                                    endtry
                                    if char == 27 || char == 3
                                        " Escape or <C-c> key pressed
                                        redraw
                                        call s:Message('Cancelled')
                                        return ''
                                    endif
                                    " Workaround for the <expr> mappings
                                    if string(char) !=# "\x80\xfd`"
                                        return mode == 1 ? !!char
                                        \    : type(char) == type(0) ? nr2char(char) : char
                                    endif
                                endwhile
                            endfunction "}}}
                            
                            " -- Find Motion Helper ------------------
    1              0.000004 function! s:findMotion(num_strokes, direction) "{{{
                                " Find Motion: S,F,T
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " store cursor pos because 'n' key find motion could be jump to offscreen
                                let s:current.original_position = [line('.'), col('.')]
                                let s:current.is_search = a:num_strokes == -1 ? 1: 0
                                let s:flag.regexp = a:num_strokes == -1 ? 1 : 0 " TODO: remove?
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let s:previous['input'] = @/
                                else
                                    let s:previous['input'] = get(s:previous, 'input', '')
                                endif
                                let input = EasyMotion#command_line#GetInput(
                                                \ a:num_strokes, s:previous.input, a:direction)
                                let s:previous['input'] = input
                            
                                " Check that we have an input char
                                if empty(input)
                                    return ''
                                endif
                            
                                let re = s:convertRegep(input)
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let history_re = substitute(re, '\\c\|\\C', '', '')
                                    let @/ = history_re "For textobject: 'gn'
                                    call histadd('search', history_re)
                                endif
                            
                                return re
                            endfunction "}}}
    1              0.000004 function! s:convertRegep(input) "{{{
                                " 1. regexp
                                " 2. migemo
                                " 3. smartsign
                                " 4. smartcase
                                let use_migemo = s:should_use_migemo(a:input)
                                let re = use_migemo || s:should_use_regexp() ? a:input : s:escape_regexp_char(a:input)
                            
                                " Convert space to match only start of spaces
                                if re ==# ' '
                                    let re = '\s\+'
                                endif
                            
                                if use_migemo
                                    let re = s:convertMigemo(re)
                                endif
                            
                                if s:should_use_smartsign(a:input)
                                    let r = s:convertSmartsign(a:input)
                                    if use_migemo
                                        let re = re . '\m\|' . r
                                    else
                                        let re = r
                                    endif
                                endif
                            
                                let case_flag = EasyMotion#helper#should_case_sensitive(
                                                    \ a:input, s:current.is_search) ? '\c' : '\C'
                                let re = case_flag . re
                                return re
                            endfunction "}}}
    1              0.000004 function! s:convertMigemo(re) "{{{
                                let re = a:re
                            
                                if len(re) > 1
                                    " System cmigemo
                                    return EasyMotion#cmigemo#getMigemoPattern(re)
                                endif
                            
                                " EasyMotion migemo one key dict
                                if ! has_key(s:migemo_dicts, &l:encoding)
                                    let s:migemo_dicts[&l:encoding] = EasyMotion#helper#load_migemo_dict()
                                endif
                                return get(s:migemo_dicts[&l:encoding], re, a:re)
                            endfunction "}}}
    1              0.000004 function! s:convertSmartsign(chars) "{{{
                                " Convert given chars to smartsign string
                                " Example: 12 -> [1!][2@]
                                "          a] -> a[]}]
                            
                                " Load smartsign dictionary
                                let smart_dict = s:load_smart_dict()
                                " Prepare converted string
                                let converted_str = ''
                                " Get `upper_sign` for each given chars
                                " Split chars into list
                                for char in split(a:chars, '\zs')
                                    let upper_sign = s:get_escaped_group_char(smart_dict, char)
                                    if upper_sign ==# ''
                                        let converted_str .= s:escape_regexp_char(char)
                                    else
                                        " [1!]
                                        let converted_str .= '[' . char . upper_sign . ']'
                                    endif
                                endfor
                                return converted_str
                            endfunction "}}}
    1              0.000006 function! s:get_escaped_group_char(dict, char) "{{{
                                " Get escaped char from given dictionary
                                " return '' if char is not find
                                " Used inside `[]`
                                return escape(get(a:dict, a:char, ''), '^')
                            endfunction "}}}
    1              0.000004 function! s:escape_regexp_char(char) "{{{
                                return escape(a:char, '.$^~\[]*')
                            endfunction "}}}
    1              0.000004 function! s:convertSmartcase(re, char) "{{{
                                let re = a:re
                                if a:char =~# '\U' "nonuppercase
                                    return '\c' . re
                                else "uppercase
                                    return '\C' . re
                                endif
                            endfunction "}}}
    1              0.000003 function! s:should_use_regexp() "{{{
                                return g:EasyMotion_use_regexp == 1 && s:flag.regexp == 1
                            endfunction "}}}
    1              0.000004 function! s:should_use_migemo(char) "{{{
                                if ! g:EasyMotion_use_migemo || match(a:char, '[^!-~]') != -1
                                    return 0
                                endif
                            
                                " TODO: use direction to improve
                                if s:flag.within_line == 1
                                    let first_line = line('.')
                                    let end_line = line('.')
                                else
                                    let first_line = line('w0')
                                    let end_line = line('w$')
                                endif
                            
                                " Skip folded line and check if text include multibyte characters
                                for line in range(first_line, end_line)
                                    if EasyMotion#helper#is_folded(line)
                                        continue
                                    endif
                            
                                    if EasyMotion#helper#include_multibyte_char(getline(line)) == 1
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction "}}}
    1              0.000004 function! s:should_use_smartsign(char) "{{{
                                " Smartsign Dictionary exists?
                                " \A: non-alphabetic character
                                " Do not use smartsign for n-key find search motions
                                if (exists('g:EasyMotion_use_smartsign_us')  ||
                                \   exists('g:EasyMotion_use_smartsign_jp')) &&
                                \  match(a:char, '\A') != -1 &&
                                \ exists('s:current.is_search') && s:current.is_search == 0
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction "}}}
    1              0.000005 function! s:convert_t_regexp(re, direction) "{{{
                                if a:direction == 0 "forward
                                    return '\_.\ze\('.a:re.'\)'
                                elseif a:direction == 1 "backward
                                    return '\('.a:re.'\)\@<=\_.'
                                endif
                            endfunction "}}}
                            
                            " -- Handle Visual Mode ------------------
    1              0.000007 function! s:GetVisualStartPosition(c_pos, v_start, v_end, search_direction) "{{{
                                let vmode = mode(1)
                                if vmode !~# "^[Vv\<C-v>]"
                                    call s:Throw('Unkown visual mode:'.vmode)
                                endif
                            
                                if vmode ==# 'V' "line-wise Visual
                                    " Line-wise Visual {{{
                                    if a:v_start[0] == a:v_end[0]
                                        if a:search_direction == ''
                                            return a:v_start
                                        elseif a:search_direction == 'b'
                                            return a:v_end
                                        else
                                            call s:throw('Unkown search_direction')
                                        endif
                                    else
                                        if a:c_pos[0] == a:v_start[0]
                                            return a:v_end
                                        elseif a:c_pos[0] == a:v_end[0]
                                            return a:v_start
                                        endif
                                    endif
                                    "}}}
                                else
                                    " Character-wise or Block-wise Visual"{{{
                                    if a:c_pos == a:v_start
                                        return a:v_end
                                    elseif a:c_pos == a:v_end
                                        return a:v_start
                                    endif
                            
                                    " virtualedit
                                    if a:c_pos[0] == a:v_start[0]
                                        return a:v_end
                                    elseif a:c_pos[0] == a:v_end[0]
                                        return a:v_start
                                    elseif EasyMotion#helper#is_greater_coords(a:c_pos, a:v_start) == 1
                                        return a:v_end
                                    else
                                        return a:v_start
                                    endif
                                    "}}}
                                endif
                            endfunction "}}}
                            
                            " -- Others ------------------------------
    1              0.000005 function! s:handleEmpty(input, visualmode) "{{{
                                " if empty, reselect and return 1
                                if empty(a:input)
                                    if ! empty(a:visualmode)
                                        silent exec 'normal! gv'
                                    endif
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000004 function! s:load_smart_dict() "{{{
                                if exists('g:EasyMotion_use_smartsign_us')
                                    return g:EasyMotion#sticky_table#us
                                elseif exists('g:EasyMotion_use_smartsign_jp')
                                    return g:EasyMotion#sticky_table#jp
                                else
                                    return {}
                                endif
                            endfunction "}}}
    1              0.000004 function! EasyMotion#attach_active_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion-active
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion-active CursorMoved <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000003 function! EasyMotion#is_active() "{{{
                                return s:EasyMotion_is_active
                            endfunction "}}}
    1              0.000004 function! EasyMotion#activate(is_visual) "{{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd()
                                call EasyMotion#highlight#add_highlight(s:previous.regexp,
                                                                      \ g:EasyMotion_hl_move)
                                call EasyMotion#highlight#attach_autocmd()
                                if a:is_visual == 1
                                    normal! gv
                                endif
                            endfunction "}}}
    1              0.000004 function! s:restore_cursor_state(visualmode) "{{{
                                " -- Restore original cursor position/selection
                                if ! empty(a:visualmode)
                                    silent exec 'normal! gv'
                                    keepjumps call cursor(s:current.cursor_position)
                                else
                                    keepjumps call cursor(s:current.original_position)
                                endif
                            endfunction " }}}
                            " Grouping Algorithms: {{{
    1              0.000015 let s:grouping_algorithms = {
                            \   1: 'SCTree'
                            \ , 2: 'Original'
                            \ }
                            " -- Single-key/closest target priority tree {{{
                            " This algorithm tries to assign one-key jumps to all the targets closest to the cursor.
                            " It works recursively and will work correctly with as few keys as two.
    1              0.000005 function! s:GroupingAlgorithmSCTree(targets, keys) "{{{
                                " Prepare variables for working
                                let targets_len = len(a:targets)
                                let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let keys = reverse(copy(a:keys))
                            
                                " Semi-recursively count targets {{{
                                    " We need to know exactly how many child nodes (targets) this branch will have
                                    " in order to pass the correct amount of targets to the recursive function.
                            
                                    " Prepare sorted target count list {{{
                                        " This is horrible, I know. But dicts aren't sorted in vim, so we need to
                                        " work around that. That is done by having one sorted list with key counts,
                                        " and a dict which connects the key with the keys_count list.
                            
                                        let keys_count = []
                                        let keys_count_keys = {}
                            
                                        let i = 0
                                        for key in keys
                                            call add(keys_count, 0)
                            
                                            let keys_count_keys[key] = i
                            
                                            let i += 1
                                        endfor
                                    " }}}
                            
                                    let targets_left = targets_len
                                    let level = 0
                                    let i = 0
                            
                                    while targets_left > 0
                                        " Calculate the amount of child nodes based on the current level
                                        let childs_len = (level == 0 ? 1 : (keys_len - 1) )
                            
                                        for key in keys
                                            " Add child node count to the keys_count array
                                            let keys_count[keys_count_keys[key]] += childs_len
                            
                                            " Subtract the child node count
                                            let targets_left -= childs_len
                            
                                            if targets_left <= 0
                                                " Subtract the targets left if we added too many too
                                                " many child nodes to the key count
                                                let keys_count[keys_count_keys[key]] += targets_left
                            
                                                break
                                            endif
                            
                                            let i += 1
                                        endfor
                            
                                        let level += 1
                                    endwhile
                                " }}}
                                " Create group tree {{{
                                    let i = 0
                                    let key = 0
                            
                                    call reverse(keys_count)
                            
                                    for key_count in keys_count
                                        if key_count > 1
                                            " We need to create a subgroup
                                            " Recurse one level deeper
                                            let groups[a:keys[key]] = s:GroupingAlgorithmSCTree(a:targets[i : i + key_count - 1], a:keys)
                                        elseif key_count == 1
                                            " Assign single target key
                                            let groups[a:keys[key]] = a:targets[i]
                                        else
                                            " No target
                                            continue
                                        endif
                            
                                        let key += 1
                                        let i += key_count
                                    endfor
                                " }}}
                            
                                " Finally!
                                return groups
                            endfunction "}}}
                            " }}}
                            " -- Original ---------------------------- {{{
    1              0.000005 function! s:GroupingAlgorithmOriginal(targets, keys)
                                " Split targets into groups (1 level)
                                let targets_len = len(a:targets)
                                " let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let i = 0
                                let root_group = 0
                                try
                                    while root_group < targets_len
                                        let groups[a:keys[root_group]] = {}
                            
                                        for key in a:keys
                                            let groups[a:keys[root_group]][key] = a:targets[i]
                            
                                            let i += 1
                                        endfor
                            
                                        let root_group += 1
                                    endwhile
                                catch | endtry
                            
                                " Flatten the group array
                                if len(groups) == 1
                                    let groups = groups[a:keys[0]]
                                endif
                            
                                return groups
                            endfunction
                            " }}}
                            
                            " -- Coord/key dictionary creation ------- {{{
    1              0.000004 function! s:CreateCoordKeyDict(groups, ...)
                                " Dict structure:
                                " 1,2 : a
                                " 2,3 : b
                                let sort_list = []
                                let coord_keys = {}
                                let group_key = a:0 == 1 ? a:1 : ''
                            
                                for [key, item] in items(a:groups)
                                    let key = group_key . key
                                    "let key = ( ! empty(group_key) ? group_key : key)
                            
                                    if type(item) == type([]) " List
                                        " Destination coords
                            
                                        " The key needs to be zero-padded in order to
                                        " sort correctly
                                        let dict_key = printf('%05d,%05d', item[0], item[1])
                                        let coord_keys[dict_key] = key
                            
                                        " We need a sorting list to loop correctly in
                                        " PromptUser, dicts are unsorted
                                        call add(sort_list, dict_key)
                                    else
                                        " Item is a dict (has children)
                                        let coord_key_dict = s:CreateCoordKeyDict(item, key)
                            
                                        " Make sure to extend both the sort list and the
                                        " coord key dict
                                        call extend(sort_list, coord_key_dict[0])
                                        call extend(coord_keys, coord_key_dict[1])
                                    endif
                            
                                    unlet item
                                endfor
                            
                                return [sort_list, coord_keys]
                            endfunction
                            " }}}
                            " }}}
                            "}}}
                            " Core Functions: {{{
    1              0.000004 function! s:PromptUser(groups) "{{{
                                " Recursive
                                let group_values = values(a:groups)
                            
                                " -- If only one possible match, jump directly to it {{{
                                if len(group_values) == 1
                                    if mode(1) ==# 'no'
                                        " Consider jump to first match
                                        " NOTE: matchstr() handles multibyte characters.
                                        let s:dot_repeat['target'] = matchstr(g:EasyMotion_keys, '^.')
                                    endif
                                    redraw
                                    return group_values[0]
                                endif
                                " }}}
                            
                                " -- Prepare marker lines ---------------- {{{
                                let lines = {}
                            
                                let coord_key_dict = s:CreateCoordKeyDict(a:groups)
                            
                                let prev_col_num = 0
                                for dict_key in sort(coord_key_dict[0])
                                    " NOTE: {{{
                                    " let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                    " Perform <Plug>(easymotion-w)
                                    "
                                    " lines[line_num]['orig']:
                                    "   Lorem ipsum dolor sit amet consectetur adipisicing
                                    "
                                    " {target_char}:
                                    "   {L}orem {i}psum {d}olor {s}it {a}met {c}onsectetur {a}dipisicing
                                    "
                                    " lines[line_num]['marker'], {marker_chars}:
                                    "   {A}orem {B}psum {C}olor {D}it {E}met {F}onsectetur {G}dipisicing
                                    "   2-key-combo: {marker_chars} could be 1 or 2 chars like {AB}
                                    "
                                    " }}}
                            
                                    " Prepare original line and marker line {{{
                                    let [line_num, col_num] = split(dict_key, ',')
                            
                                    let line_num = str2nr(line_num)
                                    let col_num = str2nr(col_num)
                                    if ! has_key(lines, line_num)
                                        let current_line = getline(line_num)
                                        let lines[line_num] = {
                                            \ 'orig': current_line,
                                            \ 'marker': current_line,
                                            \ 'mb_compensation': 0,
                                            \ }
                                        " mb_compensation -> multibyte compensation
                                        let prev_col_num = 0
                                    endif "}}}
                            
                                    " Multibyte Compensation: {{{
                                    " Solve multibyte issues by matching the byte column
                                    " number instead of the visual column
                                    " Compensate for byte difference between marker
                                    " character and target character
                                    "
                                    " This has to be done in order to match the correct
                                    " column; \%c matches the byte column and not display
                                    " column.
                                    let col_num = max([prev_col_num + 1,
                                                    \  col_num - lines[line_num]['mb_compensation']])
                                    let prev_col_num = col_num
                                    "}}}
                            
                                    " Prepare marker characters {{{
                                    let marker_chars = coord_key_dict[1][dict_key]
                                    let marker_chars_len = EasyMotion#helper#strchars(marker_chars)
                                    "}}}
                            
                                    " Replace {target} with {marker} & Highlight {{{
                                    let col_add = 0 " Column add byte length
                                    " Disable two-key-combo feature?
                                    let marker_max_length = g:EasyMotion_disable_two_key_combo == 1
                                                            \ ? 1 : 2
                                    for i in range(min([marker_chars_len, marker_max_length]))
                                        let marker_char = split(marker_chars, '\zs')[i]
                                        " EOL {{{
                                        if strlen(lines[line_num]['marker']) < col_num + col_add
                                            " Append marker chars if target is EOL
                                            let lines[line_num]['marker'] .= ' '
                                        endif "}}}
                            
                                        let target_col_regexp = '\%' . (col_num + col_add) . 'c.'
                                        let target_char = matchstr(lines[line_num]['marker'],
                                                                  \ target_col_regexp)
                                        let space_len = strdisplaywidth(target_char)
                                                    \ - strdisplaywidth(marker_char)
                                        " Substitute marker character
                                        let substitute_expr = marker_char . repeat(' ', space_len)
                            
                                        let lines[line_num]['marker'] = substitute(
                                            \ lines[line_num]['marker'],
                                            \ target_col_regexp,
                                            \ escape(substitute_expr,'&'),
                                            \ '')
                            
                                        " Highlight targets {{{
                                        let _hl_group =
                                        \   (marker_chars_len == 1) ? g:EasyMotion_hl_group_target
                                        \   : (i == 0) ? g:EasyMotion_hl2_first_group_target
                                        \   : g:EasyMotion_hl2_second_group_target
                            
                                        if exists('*matchaddpos')
                                            call EasyMotion#highlight#add_pos_highlight(
                                                        \ line_num, col_num + col_add, _hl_group)
                                        else
                                            call EasyMotion#highlight#add_highlight(
                                                \ '\%' . line_num . 'l' . target_col_regexp,
                                                \ _hl_group)
                                        endif
                                        "}}}
                            
                                        " Add marker/target length difference for multibyte compensation
                                        let lines[line_num]['mb_compensation'] +=
                                            \ strlen(target_char) - strlen(substitute_expr)
                                        " Shift column
                                        let col_add += strlen(marker_char)
                                    endfor
                                    "}}}
                                endfor
                            
                                let lines_items = items(lines)
                                " }}}
                            
                                " -- Put labels on targets & Get User Input & Restore all {{{
                                " Save undo tree
                                let undo_lock = EasyMotion#undo#save()
                                try
                                    " Set lines with markers {{{
                                    call s:SetLines(lines_items, 'marker')
                                    redraw "}}}
                            
                                    " Get target character {{{
                                    call s:Prompt('Target key')
                                    let char = s:GetChar()
                                    "}}}
                            
                                    " Convert uppercase {{{
                                    if g:EasyMotion_use_upper == 1 && match(g:EasyMotion_keys, '\l') == -1
                                        let char = toupper(char)
                                    endif "}}}
                            
                                    " Jump first target when Enter or Space key is pressed "{{{
                                    if (char ==# "\<CR>" && g:EasyMotion_enter_jump_first == 1) ||
                                    \  (char ==# "\<Space>" && g:EasyMotion_space_jump_first == 1)
                                        " NOTE: matchstr() is multibyte aware.
                                        let char = matchstr(g:EasyMotion_keys, '^.')
                                    endif "}}}
                            
                                    " For dot repeat {{{
                                    if mode(1) ==# 'no'
                                        " Store previous target when operator pending mode
                                        if s:current.dot_prompt_user_cnt == 0
                                            " Store
                                            let s:dot_repeat['target'] = char
                                        else
                                            " Append target chars
                                            let s:dot_repeat['target'] .= char
                                        endif
                                    endif "}}}
                            
                                finally
                                    " Restore original lines
                                    call s:SetLines(lines_items, 'orig')
                            
                                    " Un-highlight targets {{{
                                    call EasyMotion#highlight#delete_highlight(
                                        \ g:EasyMotion_hl_group_target,
                                        \ g:EasyMotion_hl2_first_group_target,
                                        \ g:EasyMotion_hl2_second_group_target,
                                        \ )
                                    " }}}
                            
                                    " Restore undo tree
                                    call undo_lock.restore()
                            
                                    redraw
                                endtry "}}}
                            
                                " -- Check if we have an input char ------ {{{
                                if empty(char)
                                    call s:Throw('Cancelled')
                                endif
                                " }}}
                                " -- Check if the input char is valid ---- {{{
                                if ! has_key(a:groups, char)
                                    call s:Throw('Invalid target')
                                endif
                                " }}}
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    let s:current.dot_prompt_user_cnt += 1
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
    1              0.000004 function! s:DotPromptUser(groups) "{{{
                                " Get char from previous target
                                let char = s:dot_repeat.target[s:current.dot_repeat_target_cnt]
                                " For dot repeat target chars
                                let s:current.dot_repeat_target_cnt += 1
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
                            
    1              0.000005 function! s:EasyMotion(regexp, direction, visualmode, is_inclusive, ...) " {{{
                                let config = extend(s:default_config(), get(a:, 1, {}))
                                " Store s:current original_position & cursor_position {{{
                                " current cursor pos.
                                let s:current.cursor_position = [line('.'), col('.')]
                                " original start position.  This value could be changed later in visual
                                " mode
                                let s:current.original_position =
                                    \ get(s:current, 'original_position', s:current.cursor_position)
                                "}}}
                            
                                let win_first_line = line('w0') " visible first line num
                                let win_last_line  = line('w$') " visible last line num
                            
                                " Store the target positions list
                                " e.g. targets = [ [line, col], [line2, col2], ...]
                                let targets = []
                            
                                " Store info for Repeat motion {{{
                                if s:flag.dot_repeat != 1
                                    " Store Regular Expression
                                    let s:previous['regexp'] = a:regexp
                                    let s:previous['direction'] = a:direction
                                    let s:previous['operator'] = v:operator
                            
                                    " Note: 'is_inclusive' value could be changed later when
                                    " bi-directional find motion depend on 'true' direction the cursor
                                    " will move.
                                    let s:previous['is_inclusive'] = a:is_inclusive
                            
                                    " For special motion flag
                                    let s:previous['line_flag'] = s:flag.within_line
                                    let s:previous['bd_t_flag'] = s:flag.bd_t " bi-directional t motion
                                endif "}}}
                            
                                " To avoid side effect of overwriting buffer for tpope/repeat
                                " store current b:changedtick. Use this value later
                                let s:current.changedtick = b:changedtick
                            
                                try
                                    " -- Reset properties -------------------- {{{
                                    " Save original value and set new value
                                    call s:SaveValue()
                                    call s:turn_off_hl_error()
                                    " }}}
                                    " Setup searchpos args {{{
                                    let search_direction = (a:direction == 1 ? 'b' : '')
                                    let search_stopline = a:direction == 1 ? win_first_line : win_last_line
                            
                                    if s:flag.within_line == 1
                                        let search_stopline = s:current.original_position[0]
                                    endif
                                    "}}}
                            
                                    " Handle visual mode {{{
                                    if ! empty(a:visualmode)
                                        " Decide at where visual mode start {{{
                                        normal! gv
                                        let v_start = [line("'<"),col("'<")] " visual_start_position
                                        let v_end   = [line("'>"),col("'>")] " visual_end_position
                            
                                        let v_original_pos = s:GetVisualStartPosition(
                                            \ s:current.cursor_position, v_start, v_end, search_direction)
                                        "}}}
                            
                                        " Reselect visual text {{{
                                        keepjumps call cursor(v_original_pos)
                                        exec "normal! " . a:visualmode
                                        keepjumps call cursor(s:current.cursor_position)
                                        "}}}
                                        " Update s:current.original_position
                                        " overwrite original start position
                                        let s:current.original_position = v_original_pos
                                    endif "}}}
                            
                                    " Handle bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 0) "forward
                                    else
                                        let regexp = a:regexp
                                    endif
                                    "}}}
                            
                                    " Handle dot repeat with count
                                    if s:flag.count_dot_repeat
                                        let cursor_char = EasyMotion#helper#get_char_by_coord(s:current.cursor_position)
                                        if cursor_char =~# regexp
                                            call add(targets, s:current.cursor_position)
                                        endif
                                    endif
                            
                                    " Construct match dict {{{
                                    " Note: searchpos() has side effect which jump cursor position.
                                    "       You can disable this side effect by add 'n' flags,
                                    "       but in this case, it's better to allows jump side effect
                                    "       to gathering matched targets coordinates.
                                    let pos = searchpos(regexp, search_direction . (config.accept_cursor_pos ? 'c' : ''), search_stopline)
                                    while 1
                                        " Reached end of search range
                                        if pos == [0, 0]
                                            break
                                        endif
                            
                                        " Skip folded lines {{{
                                        if EasyMotion#helper#is_folded(pos[0])
                                            if search_direction ==# 'b'
                                                " FIXME: Hmm... I should use filter()
                                                " keepjumps call cursor(foldclosed(pos[0]), 0)
                                            else
                                                keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                            endif
                                        else
                                            call add(targets, pos)
                                        endif
                                        "}}}
                                        let pos = searchpos(regexp, search_direction, search_stopline)
                                    endwhile
                                    "}}}
                            
                                    " Handle bidirection "{{{
                                    " For bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 1) "backward
                                    endif
                                    "}}}
                                    " Reconstruct match dict
                                    if a:direction == 2
                                        " Backward
                            
                                        " Jump back cursor_position
                                        keepjumps call cursor(s:current.cursor_position[0],
                                                            \ s:current.cursor_position[1])
                            
                                        let targets2 = []
                                        if s:flag.within_line == 0
                                            let search_stopline = win_first_line
                                        else
                                            let search_stopline = s:current.cursor_position[0]
                                        endif
                                        while 1
                                            " TODO: refactoring
                                            let pos = searchpos(regexp, 'b', search_stopline)
                                            " Reached end of search range
                                            if pos == [0, 0]
                                                break
                                            endif
                            
                                            " Skip folded lines {{{
                                            if EasyMotion#helper#is_folded(pos[0])
                                                " keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                                continue
                                            endif
                                            "}}}
                            
                                            call add(targets2, pos)
                                        endwhile
                                        " Merge match target dict"{{{
                                        let t1 = 0 " forward
                                        let t2 = 0 " backward
                                        let targets3 = []
                                        while t1 < len(targets) || t2 < len(targets2)
                                            " Forward -> Backward -> F -> B -> ...
                                            if t1 < len(targets)
                                                call add(targets3, targets[t1])
                                                let t1 += 1
                                            endif
                                            if t2 < len(targets2)
                                                call add(targets3, targets2[t2])
                                                let t2 += 1
                                            endif
                                        endwhile
                                        let targets = targets3
                                        "}}}
                                    endif
                                    "}}}
                                    " Handle no match"{{{
                                    let targets_len = len(targets)
                                    if targets_len == 0
                                        call s:Throw('No matches')
                                    endif
                                    "}}}
                            
                                    " Attach specific key as marker to gathered matched coordinates
                                    let GroupingFn = function('s:GroupingAlgorithm' . s:grouping_algorithms[g:EasyMotion_grouping])
                                    let groups = GroupingFn(targets, split(g:EasyMotion_keys, '\zs'))
                            
                                    " -- Shade inactive source --------------- {{{
                                    if g:EasyMotion_do_shade && targets_len != 1 && s:flag.dot_repeat != 1
                                        if a:direction == 1 " Backward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#'
                                                            \ : '\%'. win_first_line .'l\_.*\%#'
                                        elseif a:direction == 0 " Forward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '\%#.*$'
                                                            \ : '\%#\_.*\%'. win_last_line .'l'
                                        else " Both directions
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#.*$'
                                                            \ : '\_.*'
                                        endif
                            
                                        call EasyMotion#highlight#add_highlight(
                                            \ shade_hl_re, g:EasyMotion_hl_group_shade)
                                        if g:EasyMotion_cursor_highlight
                                            let cursor_hl_re = '\%#'
                                            call EasyMotion#highlight#add_highlight(cursor_hl_re,
                                                \ g:EasyMotion_hl_inc_cursor)
                                        endif
                                    endif
                                    " }}}
                            
                                    " -- Jump back before prompt for visual scroll {{{
                                    " Because searchpos() change current cursor position and
                                    " if you just use cursor(s:current.cursor_position) to jump back,
                                    " current line will become middle of line window
                                    if ! empty(a:visualmode)
                                        keepjumps call winrestview({'lnum' : s:current.cursor_position[0], 'topline' : win_first_line})
                                    else
                                        " for adjusting cursorline
                                        keepjumps call cursor(s:current.cursor_position)
                                    endif
                                    "}}}
                            
                                    " -- Prompt user for target group/character {{{
                                    if s:flag.dot_repeat != 1
                                        let coords = s:PromptUser(groups)
                                    else
                                        let coords = s:DotPromptUser(groups)
                                    endif
                                    "}}}
                            
                                    " -- Update cursor position -------------- {{{
                                    " First, jump back cursor to original position
                                    keepjumps call cursor(s:current.original_position)
                            
                                    " Consider EasyMotion as jump motion :h jump-motion
                                    normal! m`
                            
                                    " Update selection for visual mode {{{
                                    if ! empty(a:visualmode)
                                        exec 'normal! ' . a:visualmode
                                    endif
                                    " }}}
                            
                                    " For bi-directional motion, checking again whether the motion is
                                    " inclusive is necessary. This value will might be updated later
                                    let is_inclusive_check = a:is_inclusive
                                    " For bi-directional motion, store 'true' direction for dot repeat
                                    " to handling inclusive/exclusive motion
                                    if a:direction == 2
                                        let true_direction =
                                            \ EasyMotion#helper#is_greater_coords(
                                            \   s:current.original_position, coords) > 0 ?
                                            \ 0 : 1
                                            " forward : backward
                                    else
                                        let true_direction = a:direction
                                    endif
                            
                                    if s:flag.dot_repeat == 1
                                        " support dot repeat {{{
                                        " Use visual mode to emulate dot repeat
                                        normal! v
                            
                                        " Deal with exclusive {{{
                                        if s:dot_repeat.is_inclusive == 0
                                            " exclusive
                                            if s:dot_repeat.true_direction == 0 "Forward
                                                let coords[1] -= 1
                                            elseif s:dot_repeat.true_direction == 1 "Backward
                                                " Shift visual selection to left by making cursor one key
                                                " left.
                                                normal! hoh
                                            endif
                                        endif "}}}
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " Execute previous operator
                                        let cmd = s:dot_repeat.operator
                                        if s:dot_repeat.operator ==# 'c'
                                            let cmd .= getreg('.')
                                        endif
                                        exec 'normal! ' . cmd
                                        "}}}
                                    else
                                        " Handle inclusive & exclusive {{{
                                        " Overwrite inclusive flag for special case {{{
                                        if s:flag.find_bd == 1 && true_direction == 1
                                            " Note: For bi-directional find motion s(f) & t
                                            " If true_direction is backward, the motion is 'exclusive'
                                            let is_inclusive_check = 0 " overwrite
                                            let s:previous.is_inclusive = 0 " overwrite
                                        endif "}}}
                                        if is_inclusive_check
                                            " Note: {{{
                                            " Inclusive motion requires that we eat one more
                                            " character to the right by forcing the motion to inclusive
                                            " if we're using a forward motion because
                                            " > :h exclusive
                                            " > Note that when using ':' any motion becomes characterwise
                                            " > exclusive.
                                            " and EasyMotion use ':'
                                            " See: h: o_v }}}
                                            normal! v
                                        endif " }}}
                            
                                        if s:current.is_operator && s:flag.linewise
                                            " TODO: Is there better solution?
                                            " Maike it linewise
                                            normal! V
                                        endif
                            
                                        " Adjust screen especially for visual scroll & offscreen search {{{
                                        " Otherwise, cursor line will move middle line of window
                                        keepjumps call winrestview({'lnum' : win_first_line, 'topline' : win_first_line})
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " To avoid side effect of overwriting buffer {{{
                                        " for tpope/vim-repeat
                                        " See: :h b:changedtick
                                        if exists('g:repeat_tick')
                                            if g:repeat_tick == s:current.changedtick
                                                let g:repeat_tick = b:changedtick
                                            endif
                                        endif "}}}
                                    endif
                            
                                    " Set tpope/vim-repeat {{{
                                    if s:current.is_operator == 1 &&
                                            \ !(v:operator ==# 'y' && match(&cpo, 'y') == -1)
                                        " Store previous info for dot repeat {{{
                                        let s:dot_repeat.regexp = a:regexp
                                        let s:dot_repeat.direction = a:direction
                                        let s:dot_repeat.line_flag = s:flag.within_line
                                        let s:dot_repeat.is_inclusive = is_inclusive_check
                                        let s:dot_repeat.operator = v:operator
                                        let s:dot_repeat.bd_t_flag = s:flag.bd_t " Bidirectional t motion
                                        let s:dot_repeat.true_direction = true_direction " Check inclusive
                                        "}}}
                                        silent! call repeat#set("\<Plug>(easymotion-dotrepeat)")
                                    endif "}}}
                            
                                    " Highlight all the matches by n-key find motions {{{
                                    if s:current.is_search == 1 && s:current.is_operator == 0 && g:EasyMotion_add_search_history
                                        " It seems let &hlsearch=&hlsearch doesn't work when called
                                        " in script, so use :h feedkeys() instead.
                                        " Ref: :h v:hlsearch
                                        " FIXME: doesn't work with `c` operator
                                        call EasyMotion#helper#silent_feedkeys(
                                                                \ ":let &hlsearch=&hlsearch\<CR>",
                                                                \ 'hlsearch', 'n')
                                    endif "}}}
                            
                                    call s:Message('Jumping to [' . coords[0] . ', ' . coords[1] . ']')
                                    let s:EasyMotion_is_cancelled = 0 " Success
                                    "}}}
                                catch /^EasyMotion:.*/
                                    redraw
                            
                                    " Show exception message
                                    " The verbose option will take precedence
                                    if g:EasyMotion_verbose == 1 && g:EasyMotion_ignore_exception != 1
                                        echo v:exception
                                    endif
                            
                                    let s:previous['regexp'] = a:regexp
                                    " -- Activate EasyMotion ----------------- {{{
                                    let s:EasyMotion_is_active = 1
                                    call EasyMotion#attach_active_autocmd() "}}}
                            
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                catch
                                    call s:Message(v:exception . ' : ' . v:throwpoint)
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                finally
                                    " -- Restore properties ------------------ {{{
                                    call s:RestoreValue()
                                    call s:turn_on_hl_error()
                                    call EasyMotion#reset()
                                    " }}}
                                    " -- Remove shading ---------------------- {{{
                                    call EasyMotion#highlight#delete_highlight()
                                    " }}}
                            
                                    if s:EasyMotion_is_cancelled == 0 " Success
                                        " -- Landing Highlight ------------------- {{{
                                        if g:EasyMotion_landing_highlight
                                            call EasyMotion#highlight#add_highlight(a:regexp,
                                                                                  \ g:EasyMotion_hl_move)
                                            call EasyMotion#highlight#attach_autocmd()
                                        endif "}}}
                                        " -- Activate EasyMotion ----------------- {{{
                                        let s:EasyMotion_is_active = 1
                                        call EasyMotion#attach_active_autocmd() "}}}
                                    endif
                                endtry
                            endfunction " }}}
                            "}}}
                            " }}}
                            
    1   0.003668   0.000026 call EasyMotion#init()
                            " Restore 'cpoptions' {{{
    1   0.000032   0.000024 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /home/valde/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim
Sourced 1 time
Total time:   0.003106
 Self time:   0.001257

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: highlight.vim
                            " AUTHOR: haya14busa
                            " Reference: https://github.com/t9md/vim-smalls
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000006 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000022 let s:save_cpo = &cpo
    1   0.000046   0.000038 set cpo&vim
                            " }}}
                            
    1              0.000006 function! EasyMotion#highlight#load()
                               "load
                            endfunction
                            
                            " -- Default highlighting ---------------- {{{
    1              0.000021 let g:EasyMotion_hl_group_target         = get(g:,
                                \ 'EasyMotion_hl_group_target', 'EasyMotionTarget')
    1              0.000015 let g:EasyMotion_hl2_first_group_target  = get(g:,
                                \ 'EasyMotion_hl2_first_group_target', 'EasyMotionTarget2First')
    1              0.000013 let g:EasyMotion_hl2_second_group_target = get(g:,
                                \ 'EasyMotion_hl2_second_group_target', 'EasyMotionTarget2Second')
    1              0.000012 let g:EasyMotion_hl_group_shade          = get(g:,
                                \ 'EasyMotion_hl_group_shade', 'EasyMotionShade')
                            
    1              0.000011 let g:EasyMotion_hl_inc_search     = get(g:,
                                \ 'EasyMotion_hl_inc_search', 'EasyMotionIncSearch')
    1              0.000011 let g:EasyMotion_hl_inc_cursor     = get(g:,
                                \ 'EasyMotion_hl_inc_cursor', 'EasyMotionIncCursor')
    1              0.000010 let g:EasyMotion_hl_move           = get(g:,
                                \ 'EasyMotion_hl_move', 'EasyMotionMoveHL')
                            
    1              0.000023 let s:target_hl_defaults = {
                                \   'gui'     : ['NONE', '#ff0000' , 'bold']
                                \ , 'cterm256': ['NONE', '196'     , 'bold']
                                \ , 'cterm'   : ['NONE', 'red'     , 'bold']
                                \ }
                            
    1              0.000018 let s:target_hl2_first_defaults = {
                                \   'gui'     : ['NONE', '#ffb400' , 'bold']
                                \ , 'cterm256': ['NONE', '11'      , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000016 let s:target_hl2_second_defaults = {
                                \   'gui'     : ['NONE', '#b98300' , 'bold']
                                \ , 'cterm256': ['NONE', '3'       , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000015 let s:shade_hl_defaults = {
                                \   'gui'     : ['NONE', '#777777' , 'NONE']
                                \ , 'cterm256': ['NONE', '242'     , 'NONE']
                                \ , 'cterm'   : ['NONE', 'grey'    , 'NONE']
                                \ }
                            
    1              0.000015 let s:shade_hl_line_defaults = {
                                \   'gui'     : ['red' , '#FFFFFF' , 'NONE']
                                \ , 'cterm256': ['red' , '242'     , 'NONE']
                                \ , 'cterm'   : ['red' , 'grey'    , 'NONE']
                                \ }
                            
    1              0.000016 let s:target_hl_inc = {
                                \   'gui'     : ['NONE', '#7fbf00' , 'bold']
                                \ , 'cterm256': ['NONE', '40'   , 'bold']
                                \ , 'cterm'   : ['NONE', 'green'   , 'bold']
                                \ }
    1              0.000017 let s:target_hl_inc_cursor = {
                                \   'gui'     : ['#ACDBDA', '#121813' , 'bold']
                                \ , 'cterm256': ['cyan'   , '232'   , 'bold']
                                \ , 'cterm'   : ['cyan'   , 'black'   , 'bold']
                                \ }
    1              0.000016 let s:target_hl_move = {
                                \   'gui'     : ['#7fbf00', '#121813' , 'bold']
                                \ , 'cterm256': ['green'  , '15'   , 'bold']
                                \ , 'cterm'   : ['green'  , 'white'   , 'bold']
                                \ }
                            " }}}
    1              0.000006 function! EasyMotion#highlight#InitHL(group, colors) " {{{
                                let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
                                let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
                                let ctermhl = &t_Co == 256
                                    \ ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2])
                                    \ : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
                                execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
                                if hlexists(a:group)
                                    redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
                                    if hlstatus !~ 'cleared'
                                        return
                                    endif
                                endif
                            
                                " No colors are defined for this group, link to defaults
                                execute printf('hi default link %s %s', a:group, group_default)
                            endfunction " }}}
    1              0.000005 function! EasyMotion#highlight#init() "{{{
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
                                if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
                                endif
                            endfunction "}}}
                            
                            " Reset highlighting after loading a new color scheme {{{
    1              0.000005 augroup EasyMotionInitHL
    1              0.000372     autocmd!
    1              0.000023     autocmd ColorScheme * call EasyMotion#highlight#init()
    1              0.000003 augroup end
                            " }}}
                            
    1   0.001857   0.000028 call EasyMotion#highlight#init()
                            " Init: {{{
    1              0.000009 let s:h = {}
    1              0.000006 let s:h.ids = {}
    1              0.000036 let s:priorities = {
                                \  g:EasyMotion_hl_group_target : 100,
                                \  g:EasyMotion_hl2_first_group_target : 100,
                                \  g:EasyMotion_hl2_second_group_target : 100,
                                \  g:EasyMotion_hl_group_shade : 0,
                                \  g:EasyMotion_hl_inc_search : 1,
                                \  g:EasyMotion_hl_inc_cursor : 2,
                                \  g:EasyMotion_hl_move : 0,
                                \ }
    8              0.000030 for s:group in keys(s:priorities)
    7              0.000035     let s:h.ids[s:group] = []
    8              0.000011 endfor
    1              0.000005 unlet s:group
                            "}}}
                            
    1              0.000007 function! EasyMotion#highlight#delete_highlight(...) "{{{
                                let groups = !empty(a:000) ? a:000 : keys(s:priorities)
                                for group in groups
                                    for id in s:h.ids[group]
                                        silent! call matchdelete(id)
                                    endfor
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
    1              0.000006 function! EasyMotion#highlight#add_highlight(re, group) "{{{
                                call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))
                            endfunction "}}}
    1              0.000007 function! EasyMotion#highlight#add_pos_highlight(line_num, col_num, group) "{{{
                                call add(s:h.ids[a:group], matchaddpos(a:group, [[a:line_num, a:col_num]], s:priorities[a:group]))
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#attach_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion CursorMoved <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000005 function! EasyMotion#highlight#add_color_group(new_groups) "{{{
                                let s:priorities = extend(deepcopy(s:priorities), a:new_groups)
                                for group in keys(a:new_groups)
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
                            
    1              0.000005 function! EasyMotion#highlight#capture(hlname) "{{{
                                " Based On: https://github.com/t9md/vim-ezbar
                                "           https://github.com/osyo-manga/vital-over
                                let hlname = a:hlname
                                if !hlexists(hlname)
                                    return
                                endif
                                while 1
                                    let save_verbose = &verbose
                                    let &verbose = 0
                                    try
                                        redir => HL_SAVE
                                        execute 'silent! highlight ' . hlname
                                        redir END
                                    finally
                                        let &verbose = save_verbose
                                    endtry
                                    if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                        return ''
                                    endif
                                    " follow highlight link
                                    let ml = matchlist(HL_SAVE, 'links to \zs.*')
                                    if !empty(ml)
                                        let hlname = ml[0]
                                        continue
                                    endif
                                    break
                                endwhile
                                let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'),
                                                       \ '[ \t\n]\+', ' ', 'g')
                                return [hlname, HL_SAVE]
                            endfunction "}}}
    1              0.000005 function! EasyMotion#highlight#turn_off(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' NONE'
                            endfunction "}}}
    1              0.000005 function! EasyMotion#highlight#turn_on(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' ' . a:hl[1]
                            endfunction "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000056   0.000044 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=4 shiftwidth=4
                            " vim: foldmethod=marker
                            " }}}

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 131
Called 12 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   12              0.000037   if s:is_vim
                                return a:client['channel']
   12              0.000015   endif
   12              0.000055   return a:client['chan_id']

FUNCTION  <SNR>58_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 189
Called 49 times
Total time:   0.039425
 Self time:   0.003712

count  total (s)   self (s)
   49              0.000139   if pumvisible()
                                return
   49              0.000036   endif
   49              0.000280   let group = a:from.'_to_'.a:to.a:suffix
   49   0.010286   0.000716   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   49   0.009817   0.000736   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   49              0.000085   if a:inverse
   14              0.000093     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   35              0.000027   else
   35              0.000226     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   49              0.000035   endif
   49              0.000223   let a:dict[group] = colors
   49   0.017817   0.000756   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>61_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 192
Called 19 times
Total time:   0.003127
 Self time:   0.002696

count  total (s)   self (s)
   19              0.000384   let file = expand("%:p")
   19              0.000245   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   19              0.000017   endif
                            
   19              0.000058   let needs_update = 1
   19              0.000151   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
   57              0.000182   for vcs in keys(s:vcs_config)
   38              0.000279     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
   38              0.000030     endif
   38              0.000171     if has_key(s:vcs_config[vcs].untracked, file)
   19              0.000042       let needs_update = 0
   19   0.000835   0.000404       call airline#extensions#branch#update_untracked_config(file, vcs)
   38              0.000028     endif
   57              0.000068   endfor
                            
   19              0.000039   if !needs_update
   19              0.000026     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 14
Called 19 times
Total time:   0.000900
 Self time:   0.000224

count  total (s)   self (s)
   19   0.000889   0.000213   return airline#extensions#coc#get('error')

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 977
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000014   if exists('#User#'.a:name)
                                exe 'doautocmd User '.a:name
    1              0.000002   endif

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 199
Called 19 times
Total time:   0.136235
 Self time:   0.004593

count  total (s)   self (s)
   19              0.000122   if !has_key(s:contexts, a:winnr)
                                return ''
   19              0.000031   endif
   19              0.000113   let context = s:contexts[a:winnr]
                            
   19              0.000104   if get(w:, 'airline_active', 1)
   19              0.000102     let l:m = mode(1)
   19              0.000063     if l:m ==# "i"
    8              0.000032       let l:mode = ['insert']
   11              0.000039     elseif l:m[0] ==# "i"
    1              0.000005       let l:mode = ['insert']
   10              0.000021     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   10              0.000020     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   10              0.000156     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   10              0.000018     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   10              0.000019     elseif l:m[0] ==# "c"
    2              0.000013       let l:mode = ['commandline']
    8              0.000014     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
    8              0.000020     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
    8              0.000007     else
    8              0.000027       let l:mode = ['normal']
   19              0.000020     endif
   19              0.000143     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   19              0.000017     endif
   19              0.000188     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   18              0.000062       let l:m = l:m[0]
   19              0.000018     endif
   19              0.000156     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   19              0.000020   endif
                            
   19              0.000124   if g:airline_detect_modified && &modified
   11              0.000048     call add(l:mode, 'modified')
   19              0.000018   endif
                            
   19              0.000064   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   19              0.000016   endif
                            
   19              0.000331   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   19              0.000015   endif
                            
   19              0.000070   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   19              0.000013   endif
                            
   19              0.000062   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
   19              0.000013   endif
                            
   19              0.000138   let mode_string = join(l:mode)
   19              0.000115   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.004957   0.000219     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.126281   0.000224     call airline#highlighter#highlight(l:mode, context.bufnr)
    7   0.001016   0.000169     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000033     let w:airline_lastmode = mode_string
   19              0.000015   endif
                            
   19              0.000036   return ''

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 49
Called 133 times
Total time:   0.002167
 Self time:   0.002167

count  total (s)   self (s)
  133              0.000539   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  133              0.000107   endif
  133              0.000608   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  133              0.000606   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 183
Called 19 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   19              0.000114   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   19              0.000132   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   19              0.000015   endif

FUNCTION  <SNR>60_get_hunks_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 72
Called 19 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
   19              0.000034   return ''

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim line 31
Called 98 times
Total time:   0.018651
 Self time:   0.001803

count  total (s)   self (s)
   98   0.018594   0.001746   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>60_coc_git_enabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 18
Called 19 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   19              0.000131   if !exists("*CocAction") || !get(g:, 'airline#extensions#hunks#coc_git', 0)
                                 " coc-git extension is disabled by default
                                 " unless specifically being enabled by the user
                                 " (as requested from coc maintainer)
   19              0.000026     return 0
                              endif
                              return 1

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 151
Called 19 times
Total time:   0.002080
 Self time:   0.000420

count  total (s)   self (s)
   19   0.002068   0.000409   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 10
Called 19 times
Total time:   0.001019
 Self time:   0.000240

count  total (s)   self (s)
   19   0.001008   0.000229   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 45
Called 19 times
Total time:   0.001165
 Self time:   0.000320

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
   19   0.001132   0.000288   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 143
Called 38 times
Total time:   0.000424
 Self time:   0.000424

count  total (s)   self (s)
   38              0.000149   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   38              0.000026   endif
   38              0.000077   return s:has_fugitive

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 90
Called 3 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    3              0.000036   let pos = getcurpos()
    3              0.000027   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
    3              0.000021   return [pos[1] - 1, strchars(content)]

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 102
Called 19 times
Total time:   0.000569
 Self time:   0.000304

count  total (s)   self (s)
   19   0.000554   0.000289   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '‚Ä¶' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 82
Called 19 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   19              0.000088   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   19              0.000015   endif
   19              0.000024   return ''

FUNCTION  <SNR>61_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 138
Called 19 times
Total time:   0.002202
 Self time:   0.001976

count  total (s)   self (s)
   19   0.000446   0.000220   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   19              0.000019   else
   19              0.000095     let s:vcs_config['mercurial'].branch = ''
   19              0.000020   endif

FUNCTION  coc#_hide()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 98
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   if !pumvisible() | return | endif
                              call feedkeys("\<C-e>", 'in')

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 18
Called 38 times
Total time:   0.001455
 Self time:   0.001455

count  total (s)   self (s)
   38              0.000181   if !exists(':CocCommand')
                                return ''
   38              0.000027   endif
   38              0.000166   let _backup = get(g:, 'coc_stl_format', '')
   38              0.000137   let is_err = (a:type  is# 'error')
   38              0.000058   if is_err
   19              0.000123     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
   19              0.000016   else
   19              0.000134     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
   38              0.000031   endif
   38              0.000148   let info = get(b:, 'coc_diagnostic_info', {})
   38              0.000156   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 279
Called 7 times
Total time:   0.000342
 Self time:   0.000259

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000144   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000176   0.000093   call airline#update_tabline()

FUNCTION  <SNR>58_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 56
Called 289 times
Total time:   0.004572
 Self time:   0.004572

count  total (s)   self (s)
  289              0.001802   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  289              0.002535   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 19
Called 189 times
Total time:   0.002782
 Self time:   0.002782

count  total (s)   self (s)
  189              0.000863   let nr = get(a:000, 0, 0)
  189              0.000654   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  189              0.000176   else
  189              0.000571     return winwidth(nr)
                              endif

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 176
Called 7 times
Total time:   0.000847
 Self time:   0.000234

count  total (s)   self (s)
    7   0.000843   0.000229   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 561
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000003   let disabled = get(b:, 'coc_suggest_disable', 0)
    1              0.000002   if disabled | return | endif
    1              0.000002   let blacklist = get(b:, 'coc_suggest_blacklist', [])
    1              0.000002   let pos = getcurpos()
    1              0.000002   let l:start = pos[2] - 1
    1              0.000002   let line = getline(pos[1])
    2              0.000009   for char in reverse(split(line[0: l:start - 1], '\zs'))
    1              0.000004     if l:start > 0 && char =~# '\k'
    1              0.000002       let l:start = l:start - strlen(char)
                                else
                                  break
    1              0.000000     endif
    2              0.000001   endfor
    1              0.000003   let input = pos[2] == 1 ? '' : line[l:start : pos[2] - 2]
    1              0.000002   if !empty(blacklist) && index(blacklist, input) >= 0
                                return
    1              0.000000   endif
    1              0.000003   let synname = synIDattr(synID(pos[1], l:start, 1),"name")
    1              0.000023   return { 'word': matchstr(line[l:start : ], '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': l:start, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': blacklist,}

FUNCTION  <SNR>28_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 59
Called 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
    1              0.000009   if &buftype is# 'popup'
                                return
    1              0.000002   endif
                            
    1              0.000008   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
    1              0.000001   endif
    1              0.000009   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    1              0.000044   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    1              0.000054   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    1              0.000002     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  EasyMotion#highlight#init()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim line 124
Called 1 time
Total time:   0.001829
 Self time:   0.000257

count  total (s)   self (s)
    1   0.000331   0.000038     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
    1   0.000263   0.000041     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
    1   0.000231   0.000032     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
    1   0.000227   0.000029     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
    1   0.000226   0.000028     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
    1   0.000216   0.000029     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
    1   0.000304   0.000029     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
    1              0.000018     if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
    1              0.000002     endif

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 301
Called 19 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   19              0.000093   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
   19              0.000017   else
   19              0.000040     return a:path
                              endif

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 195
Called 19 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
   19              0.000156   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   19              0.000016   endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim line 15
Called 19 times
Total time:   0.001582
 Self time:   0.001426

count  total (s)   self (s)
   19              0.000093   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
   19              0.000015   endif
                            
   19   0.000387   0.000230   let fmod = s:ModifierFlags()
   19              0.000061   if empty(b:fugitive_name)
   19              0.000262     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  EasyMotion#init()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim line 20
Called 1 time
Total time:   0.003642
 Self time:   0.000422

count  total (s)   self (s)
    1              0.000005     if s:loaded
                                    return
    1              0.000002     endif
    1              0.000005     let s:loaded = s:TRUE
    1   0.003447   0.000288     call EasyMotion#highlight#load()
                                " Store previous motion info
    1              0.000007     let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
    1              0.000004     let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
    1              0.000004     let s:migemo_dicts = {}
    1              0.000005     let s:EasyMotion_is_active = 0
    1   0.000080   0.000019     call EasyMotion#reset()
                                " Anywhere regular expression: {{{
    1              0.000012     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
    1              0.000016     let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
    1              0.000010     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
    1              0.000011     let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
    1              0.000005     let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
    1              0.000006     let g:EasyMotion_ignore_exception = 0
    1              0.000002     return ""

FUNCTION  <SNR>58_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 95
Called 150 times
Total time:   0.002843
 Self time:   0.002843

count  total (s)   self (s)
  150              0.000676   if !hlexists(a:group)
                                return 0
  150              0.001107   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  150              0.000135   endif
  150              0.000237   return 1

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 42
Called 190 times
Total time:   0.002454
 Self time:   0.001948

count  total (s)   self (s)
  190   0.001579   0.001073   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  190              0.000144   endif
  190              0.000353   return a:text

FUNCTION  <SNR>58_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 164
Called 41 times
Total time:   0.005049
 Self time:   0.005049

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   41              0.000078   let res = ''
   41              0.000075   let i = -1
  246              0.000355   while i < 4
  205              0.000340     let i += 1
  205              0.000700     let item = get(a:list, i, '')
  205              0.000333     if item is ''
  123              0.000151       continue
   82              0.000057     endif
   82              0.000105     if i == 0
                                  let res .= ' guifg='.item
   82              0.000116     elseif i == 1
                                  let res .= ' guibg='.item
   82              0.000131     elseif i == 2
   41              0.000171       let res .= ' ctermfg='.item
   41              0.000045     elseif i == 3
   32              0.000101       let res .= ' ctermbg='.item
    9              0.000010     elseif i == 4
    9              0.000073       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
   82              0.000058     endif
  123              0.000169   endwhile
   41              0.000082   return res

FUNCTION  coc#util#check_refresh()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 285
Called 1 time
Total time:   0.006549
 Self time:   0.000385

count  total (s)   self (s)
    1              0.000018   if !bufloaded(a:bufnr)
                                return 0
    1              0.000002   endif
    1              0.000011   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    1              0.000001   endif
    1              0.000008   if get(g: , 'EasyMotion_loaded', 0)
    1   0.006496   0.000332     return EasyMotion#is_active() != 1
                              endif
                              return 1

FUNCTION  <SNR>72_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 279
Called 19 times
Total time:   0.002362
 Self time:   0.000282

count  total (s)   self (s)
   19   0.002350   0.000270   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 63
Called 19 times
Total time:   0.004357
 Self time:   0.003558

count  total (s)   self (s)
   19              0.000121   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   19              0.000193   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   19              0.000014   endif
   19              0.000278   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   19              0.000099   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
   19              0.000014   endif
   19   0.001062   0.000263   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>28_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 91
Called 1 time
Total time:   0.000053
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000013   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    1              0.000001   endif
    1   0.000030   0.000016   call airline#update_tabline()

FUNCTION  EasyMotion#highlight#load()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim line 32
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                               "load

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 76
Called 19 times
Total time:   0.001605
 Self time:   0.001346

count  total (s)   self (s)
   19              0.000142   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
   19              0.000089     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
   19              0.000090     elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
   19              0.000066     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
   19              0.000085     elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
   19   0.000453   0.000241     elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
   19              0.000018     else
   19              0.000061       let b:source_func = 's:get_hunks_empty'
   19              0.000018     endif
   19              0.000016   endif
   19   0.000342   0.000296   return {b:source_func}()

FUNCTION  <SNR>64_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 184
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000023   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000005     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>72_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 104
Called 57 times
Total time:   0.000662
 Self time:   0.000662

count  total (s)   self (s)
   57              0.000267   if exists('+shellslash')
                                return tr(a:path, '\', '/')
   57              0.000057   else
   57              0.000117     return a:path
                              endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 308
Called 19 times
Total time:   0.028330
 Self time:   0.001369

count  total (s)   self (s)
   19   0.026205   0.000246   let head = airline#extensions#branch#head()
   19   0.000423   0.000296   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   19              0.000118   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   19   0.001131   0.000257   let head = airline#util#shorten(head, winwidth, minwidth)
   19              0.000141   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   19              0.000267   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  EasyMotion#reset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim line 66
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000017     let s:flag = { 'within_line' : 0, 'dot_repeat' : 0, 'regexp' : 0, 'bd_t' : 0, 'find_bd' : 0, 'linewise' : 0, 'count_dot_repeat' : 0, }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
    1              0.000014     let s:current = { 'is_operator' : 0, 'is_search' : 0, 'dot_repeat_target_cnt' : 0, 'dot_prompt_user_cnt' : 0, 'changedtick' : 0, }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
    1              0.000003     return ""

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 128
Called 19 times
Total time:   0.014790
 Self time:   0.000610

count  total (s)   self (s)
   19   0.000889   0.000258   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   19              0.000043   if empty(dir)
                                return ''
   19              0.000014   endif
   19   0.013797   0.000249   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 243
Called 7 times
Total time:   0.126057
 Self time:   0.022472

count  total (s)   self (s)
    7              0.000042   let bufnr = a:0 ? a:1 : ''
    7              0.000060   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000137   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000041   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000031   let airline_grouplist = []
    7              0.000058   let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000033   if exists("*uniq")
    7              0.000042     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000008   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   17              0.000062   for mode in reverse(mapped)
   10              0.000110     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    7              0.000046       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   95              0.000279       for kvp in items(dict)
   88              0.000265         let mode_colors = kvp[1]
   88              0.000215         let name = kvp[0]
   88              0.000401         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
   88              0.000070         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
   88              0.000975         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
   88              0.000728         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   35              0.000050           continue
   53              0.000040         endif
   53   0.001674   0.000881         if s:group_not_done(airline_grouplist, name.suffix)
   45   0.021518   0.000896           call airline#highlighter#exec(name.suffix, mode_colors)
   53              0.000050         endif
                            
   53              0.000215         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
   53              0.000052         endif
                            
  159              0.000561         for accent in keys(s:accents)
  106              0.000453           if !has_key(p.accents, accent)
                                        continue
  106              0.000085           endif
  106              0.000674           let colors = copy(mode_colors)
  106              0.000435           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
  106              0.000080           endif
  106              0.000323           if p.accents[accent][2] != ''
   53              0.000222             let colors[2] = p.accents[accent][2]
  106              0.000081           endif
  106              0.000304           if len(colors) >= 5
  106              0.000590             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  106              0.000083           endif
  106   0.003454   0.001966           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   90   0.043103   0.001846             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  106              0.000101           endif
  159              0.000183         endfor
   60              0.000062       endfor
                            
    7              0.000022       if empty(s:separators)
                                    " nothing to be done
                                    continue
    7              0.000005       endif
                                  " TODO: optimize this
   56              0.000168       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   49   0.040464   0.001040         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   56              0.000058       endfor
   10              0.000009     endif
   17              0.000042   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 31
Called 12 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   12              0.000111   if empty(s:client) || s:client['running'] == 0
                                return 0
   12              0.000015   endif
   12              0.000029   return 1

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 108
Called 19 times
Total time:   0.001051
 Self time:   0.001051

count  total (s)   self (s)
   19              0.000110   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   19              0.000074   let bomb     = &l:bomb ? '[BOM]' : ''
   19              0.000401   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   19              0.000207   if expected is# &fenc.bomb.ff
                                return ''
   19              0.000016   else
   19              0.000193     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>58_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 25
Called 159 times
Total time:   0.002281
 Self time:   0.002281

count  total (s)   self (s)
  159              0.000920   if index(a:list, a:name) == -1
  135              0.000718     call add(a:list, a:name)
  135              0.000288     return 1
   24              0.000010   else
   24              0.000037     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
   24              0.000010     endif
   24              0.000017     return 0
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 136
Called 19 times
Total time:   0.000773
 Self time:   0.000773

count  total (s)   self (s)
   19              0.000229   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   19              0.000521   return match(a:name, pat) > -1

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 273
Called 8 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    8              0.000046   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
    8              0.000010   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 49
Called 38 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
   38              0.000234   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 63
Called 19 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   19              0.000103   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 254
Called 19 times
Total time:   0.000810
 Self time:   0.000810

count  total (s)   self (s)
   19              0.000056   if empty(a:dir)
                                return ''
   19              0.000016   endif
   19              0.000092   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
   19              0.000013   endif
   19              0.000075   return s:commondirs[a:dir]

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 89
Called 19 times
Total time:   0.001390
 Self time:   0.000617

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   19   0.001106   0.000334   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   19              0.000017   endif
   19              0.000075   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   19              0.000016   else
   19              0.000064     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 495
Called 19 times
Total time:   0.013548
 Self time:   0.001755

count  total (s)   self (s)
   19              0.000115   let dir = a:0 > 1 ? a:2 : s:Dir()
   19              0.000052   if empty(dir)
                                return ''
   19              0.000016   endif
   19   0.012051   0.000258   let file = fugitive#Find('.git/HEAD', dir)
   19              0.000304   let ftime = getftime(file)
   19              0.000046   if ftime == -1
                                return ''
   19              0.000156   elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
   19              0.000016   endif
   19              0.000081   let head = s:head_cache[dir][1]
   19              0.000163   if head =~# '^ref: '
   19              0.000372     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>23_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 171
Called 12 times
Total time:   0.001971
 Self time:   0.001801

count  total (s)   self (s)
   12   0.000431   0.000262   let channel = coc#client#get_channel(self)
   12              0.000048   if empty(channel)
                                return ''
   12              0.000013   endif
   12              0.000025   try
   12              0.000026     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   12              0.000026     else
   12              0.000556       call call('rpcnotify', [channel, a:method] + a:args)
   12              0.000025     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   12              0.000025   endtry

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 104
Called 191 times
Total time:   0.083097
 Self time:   0.023156

count  total (s)   self (s)
  191              0.000560   if pumvisible()
                                return
  191              0.000170   endif
  191              0.000588   let colors = a:colors
  191              0.000404   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  191              0.000151   endif
  191   0.044426   0.003309   let old_hi = airline#highlighter#get_highlight(a:group)
  191              0.000649   if len(colors) == 4
   51              0.000186     call add(colors, '')
  191              0.000163   endif
  191              0.000497   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
  191              0.000187   else
  191              0.002149     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  191              0.000189   endif
  191   0.013750   0.002818   let colors = s:CheckDefined(colors)
  191   0.005641   0.002799   if old_hi != new_hi || !s:hl_group_exists(a:group)
   41   0.005693   0.000644     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   41              0.000624     exe cmd
   41              0.000201     if has_key(s:hl_groups, a:group)
   41              0.000178       let s:hl_groups[a:group] = colors
   41              0.000037     endif
  191              0.000153   endif

FUNCTION  <SNR>61_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 87
Called 19 times
Total time:   0.017843
 Self time:   0.002022

count  total (s)   self (s)
   19   0.000563   0.000284   call airline#util#ignore_next_focusgain()
   19   0.000481   0.000243   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
   19              0.000012   endif
   19   0.000377   0.000191   if airline#util#has_fugitive()
   19   0.015144   0.000354     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   19   0.000676   0.000346     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
   19              0.000017     endif
                              else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
   19              0.000016   endif

FUNCTION  <SNR>62_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim line 11
Called 19 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   19              0.000142   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 67
Called 19 times
Total time:   0.000838
 Self time:   0.000838

count  total (s)   self (s)
   19              0.000365   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   19              0.000078   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   19              0.000014   endif
   19              0.000028   return ''

FUNCTION  <SNR>20_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 212
Called 12 times
Total time:   0.003172
 Self time:   0.000464

count  total (s)   self (s)
   12              0.000132   if !get(g:,'coc_workspace_initialized', 0)
                                return
   12              0.000023   endif
   12   0.002950   0.000242   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>15_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 313
Called 19 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
   19              0.000080   if exists('+shellslash')
                                return tr(a:path, '\', '/')
   19              0.000016   else
   19              0.000034     return a:path
                              endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 59
Called 19 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
   19              0.000381   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  EasyMotion#is_active()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim line 775
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007     return s:EasyMotion_is_active

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 239
Called 19 times
Total time:   0.025959
 Self time:   0.000971

count  total (s)   self (s)
   19              0.000093   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   19              0.000016   endif
                            
   19   0.022097   0.000236   call s:update_branch()
   19   0.003455   0.000328   call s:update_untracked()
                            
   19              0.000128   if exists('b:airline_head') && !empty(b:airline_head)
   19              0.000041     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '‚Ä¶' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  coc#_do_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 69
Called 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000035   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    1              0.000022   if mode() =~# 'i' && &paste != 1
    1              0.000018     call feedkeys("\<Plug>CocRefresh", 'i')
    1              0.000002   endif

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 55
Called 19 times
Total time:   0.001293
 Self time:   0.000343

count  total (s)   self (s)
   19   0.001277   0.000327   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 11
Called 38 times
Total time:   0.001933
 Self time:   0.001742

count  total (s)   self (s)
   38              0.000257   if !a:0 || type(a:1) == type(0) && a:1 < 0
   19              0.000072     if exists('g:fugitive_event')
                                  return g:fugitive_event
   19              0.000019     endif
   19              0.000106     let dir = get(b:, 'git_dir', '')
   19              0.000110     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   19              0.000014     endif
   19              0.000034     return dir
   19              0.000071   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
   19              0.000059   elseif type(a:1) == type('')
   19   0.000575   0.000384     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>58_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 132
Called 191 times
Total time:   0.010932
 Self time:   0.010932

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  191              0.001182   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  191              0.000170   endif
  191              0.001253   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  191              0.000148   endif
                            
  543              0.001383   for val in a:colors
  543              0.001875     if !empty(val) && val !=# 'NONE'
  191              0.000375       return a:colors
  352              0.000303     endif
  352              0.000387   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 918
Called 19 times
Total time:   0.011793
 Self time:   0.007738

count  total (s)   self (s)
   19              0.000122   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
   19              0.000214   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
   19   0.000925   0.000690   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
   19   0.000605   0.000379   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
   19              0.000021   endif
   19              0.000104   let dir = a:0 ? a:1 : s:Dir()
   19              0.000053   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
   19              0.000015   endif
   19   0.000419   0.000217   let rev = s:Slash(a:object)
   19   0.002581   0.000219   let tree = s:Tree(dir)
   19              0.000096   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
   19              0.000041   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
   19              0.000137   elseif rev =~# '^\.git/'
   19              0.000172     let f = substitute(rev, '^\.git', '', '')
   19   0.001024   0.000214     let cdir = fugitive#CommonDir(dir)
   19              0.000151     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
   19              0.000108     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
   19              0.000191     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
   19              0.000016     else
   19              0.000102       let f = simplify(dir . f)
   19              0.000043     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
   19              0.000015   endif
   19   0.000419   0.000197   return FugitiveVimPath(f)

FUNCTION  coc#_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim line 57
Called 1 time
Total time:   0.001946
 Self time:   0.001560

count  total (s)   self (s)
    1              0.000016   let items = get(g:coc#_context, 'candidates', [])
    1              0.000010   let preselect = get(g:coc#_context, 'preselect', -1)
    1   0.001893   0.001507   call complete( g:coc#_context.start + 1, items)
    1              0.000010   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    1              0.000001   endif
    1              0.000003   return ''

FUNCTION  EasyMotion#highlight#InitHL()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim line 99
Called 7 times
Total time:   0.001571
 Self time:   0.001571

count  total (s)   self (s)
    7              0.000054     let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
    7              0.000104     let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
    7              0.000152     let ctermhl = &t_Co == 256 ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2]) : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
    7              0.000490     execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
    7              0.000247     if hlexists(a:group)
    2              0.000111         redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
    2              0.000026         if hlstatus !~ 'cleared'
    2              0.000006             return
                                    endif
    5              0.000008     endif
                            
                                " No colors are defined for this group, link to defaults
    5              0.000213     execute printf('hi default link %s %s', a:group, group_default)

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 190
Called 19 times
Total time:   0.000547
 Self time:   0.000547

count  total (s)   self (s)
   19              0.000230   if has_key(s:contexts, a:winnr)
   19              0.000266     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 158
Called 19 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   19              0.000092   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
   19              0.000017   endif
   19              0.000044   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 67
Called 289 times
Total time:   0.057965
 Self time:   0.029016

count  total (s)   self (s)
  289              0.006157   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  289              0.001778   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  289              0.000296   else
  289   0.016438   0.003556     let fg = s:get_syn(a:group, 'fg')
  289   0.014821   0.003325     let bg = s:get_syn(a:group, 'bg')
  289              0.001940     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  289              0.000490     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
  289              0.000300     else
  289   0.008731   0.004159       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  289              0.000287     endif
  289              0.000230   endif
  289              0.001596   let s:hl_groups[a:group] = res
  289              0.000471   return res

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 28
Called 76 times
Total time:   0.003469
 Self time:   0.002354

count  total (s)   self (s)
   76   0.002193   0.001078   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '‚Ä¶'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'‚Ä¶'
                                endif
   76              0.000058   else
   76              0.000145     return a:text
                              endif

FUNCTION  coc#util#set_buf_var()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 1120
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000027   if !bufloaded(a:bufnr) | return | endif
    1              0.000015   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 229
Called 7 times
Total time:   0.004738
 Self time:   0.000583

count  total (s)   self (s)
    7              0.000082   if getbufvar(a:bufnr, '&modified')
    3              0.000058     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000007   else
    4              0.000100     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    7              0.000009   endif
                            
    7              0.000027   if !empty(colors)
    7   0.004351   0.000195     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000008   endif

FUNCTION  <SNR>58_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 37
Called 578 times
Total time:   0.024377
 Self time:   0.024377

count  total (s)   self (s)
  578              0.002733   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
  578              0.000465   endif
  578              0.001116   let color = ''
  578              0.002089   if hlexists(a:group)
  578              0.004766     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  578              0.000550   endif
  578              0.002036   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  578              0.000436   endif
  578              0.001044   return color

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 19 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
   19              0.000192   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   19              0.000179     return printf('%s', (!empty(&keymap) && &iminsert ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 95
Called 12 times
Total time:   0.002708
 Self time:   0.000526

count  total (s)   self (s)
   12   0.000390   0.000178   if !coc#rpc#ready()
                                return ''
   12              0.000012   endif
   12   0.002230   0.000259   call s:client['notify'](a:method, a:args)
   12              0.000031   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 95
Called 19 times
Total time:   0.005208
 Self time:   0.002835

count  total (s)   self (s)
   19              0.000097   if !get(w:, 'airline_active', 0)
                                return ''
   19              0.000017   endif
                              " Cache values, so that it isn't called too often
   19   0.000968   0.000675   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   19              0.000014   endif
   19   0.001896   0.000292   let hunks = airline#extensions#hunks#get_raw_hunks()
   19              0.000040   let string = ''
   19   0.000390   0.000258   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   19              0.000058   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
   19              0.000017   endif
   19   0.000447   0.000376   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   19              0.000014   endif
                            
   19              0.000069   let b:airline_hunks = string
   19              0.000069   let b:airline_changenr = b:changedtick
   19   0.000481   0.000208   let s:airline_winwidth = airline#util#winwidth()
   19              0.000035   return string

FUNCTION  <SNR>61_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 173
Called 19 times
Total time:   0.021861
 Self time:   0.001817

count  total (s)   self (s)
   57              0.000225   for vcs in keys(s:vcs_config)
   38   0.020767   0.000722     call {s:vcs_config[vcs].update_branch}()
   38              0.000254     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
   38              0.000033     endif
   57              0.000083   endfor

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 63
Called 76 times
Total time:   0.000790
 Self time:   0.000790

count  total (s)   self (s)
   76              0.000283   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   76              0.000052   endif
   76              0.000317   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>38_Highlight_Matching_Pair()
    Defined: /tmp/.mount_nvimUobJuc/usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 3 times
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
                              " Remove any previous match.
    3              0.000012   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    3              0.000002   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    3              0.000015   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    3              0.000002   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    3              0.000010   let c_lnum = line('.')
    3              0.000008   let c_col = col('.')
    3              0.000007   let before = 0
                            
    3              0.000011   let text = getline(c_lnum)
    3              0.000058   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    3              0.000008   if empty(matches)
                                let [c_before, c] = ['', '']
    3              0.000003   else
    3              0.000018     let [c_before, c] = matches[1:2]
    3              0.000002   endif
    3              0.000057   let plist = split(&matchpairs, '.\zs[:,]')
    3              0.000012   let i = index(plist, c)
    3              0.000005   if i < 0
                                " not found, in Insert mode try character before the cursor
    3              0.000013     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    2              0.000004       let before = strlen(c_before)
    2              0.000002       let c = c_before
    2              0.000003       let i = index(plist, c)
    3              0.000002     endif
    3              0.000004     if i < 0
                                  " not found, nothing to do
    3              0.000004       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>15_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 164
Called 19 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
   19              0.000057   let dir = a:path
   19              0.000169   if dir =~# '/\.git$'
   19              0.000116     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim line 494
Called 19 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   19              0.000056   return s:loaded_ext

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   19   0.136235   0.004593  airline#check_mode()
    7   0.126057   0.022472  airline#highlighter#highlight()
  191   0.083097   0.023156  airline#highlighter#exec()
  289   0.057965   0.029016  airline#highlighter#get_highlight()
   49   0.039425   0.003712  <SNR>58_exec_separator()
   19   0.028330   0.001369  airline#extensions#branch#get_head()
   19   0.025959   0.000971  airline#extensions#branch#head()
  578   0.024377             <SNR>58_get_syn()
   19   0.021861   0.001817  <SNR>61_update_branch()
   98   0.018651   0.001803  airline#themes#get_highlight()
   19   0.017843   0.002022  <SNR>61_update_git_branch()
   19   0.014790   0.000610  FugitiveHead()
   19   0.013548   0.001755  fugitive#Head()
   19   0.011793   0.007738  fugitive#Find()
  191   0.010932             <SNR>58_CheckDefined()
    1   0.006549   0.000385  coc#util#check_refresh()
   19   0.005208   0.002835  airline#extensions#hunks#get_hunks()
   41   0.005049             <SNR>58_GetHiCmd()
    7   0.004738   0.000583  airline#highlighter#highlight_modified_inactive()
  289   0.004572             <SNR>58_get_array()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  289   0.057965   0.029016  airline#highlighter#get_highlight()
  578              0.024377  <SNR>58_get_syn()
  191   0.083097   0.023156  airline#highlighter#exec()
    7   0.126057   0.022472  airline#highlighter#highlight()
  191              0.010932  <SNR>58_CheckDefined()
   19   0.011793   0.007738  fugitive#Find()
   41              0.005049  <SNR>58_GetHiCmd()
   19   0.136235   0.004593  airline#check_mode()
  289              0.004572  <SNR>58_get_array()
   49   0.039425   0.003712  <SNR>58_exec_separator()
   19   0.004357   0.003558  airline#extensions#whitespace#check()
  150              0.002843  <SNR>58_hl_group_exists()
   19   0.005208   0.002835  airline#extensions#hunks#get_hunks()
  189              0.002782  airline#util#winwidth()
   19   0.003127   0.002696  <SNR>61_update_untracked()
   76   0.003469   0.002354  airline#util#shorten()
  159              0.002281  <SNR>58_group_not_done()
  133              0.002167  airline#util#append()
   19   0.017843   0.002022  <SNR>61_update_git_branch()
   19   0.002202   0.001976  <SNR>61_update_hg_branch()

